# SPDX-FileCopyrightText: 2025 ash_kotlin_multiplatform contributors
#
# SPDX-License-Identifier: MIT

defmodule AshKotlinMultiplatform.Rpc.Codegen do
  @moduledoc """
  Main orchestrator for Kotlin code generation.

  This module coordinates the generation of all Kotlin code from Ash resources,
  including:
  - Data classes for resources
  - Enum classes for atom types with :one_of constraints
  - Sealed classes for union types
  - Input types for actions
  - Result types (sealed classes for success/error)
  - RPC functions (both functional and object-oriented styles)
  - Phoenix Channel client (if enabled)
  """

  alias AshKotlinMultiplatform.Rpc.Info
  alias AshKotlinMultiplatform.Codegen.{FilterTypes, ResourceSchemas, TypedQueries}
  alias AshKotlinMultiplatform.Rpc.Codegen.TypeGenerators.{InputTypes, ResultTypes}
  alias AshKotlinMultiplatform.Rpc.Codegen.PhoenixChannel
  alias AshIntrospection.Helpers

  @doc """
  Generates Kotlin code for the given OTP application.

  ## Parameters
  - `otp_app` - The OTP application name
  - `opts` - Generation options

  ## Returns
  `{:ok, kotlin_code}` or `{:error, reason}`
  """
  def generate_kotlin_code(otp_app, opts \\ []) do
    package_name = get_package_name(otp_app, opts)

    # Collect RPC configuration
    rpc_resources = Info.get_rpc_resources(otp_app)

    if Enum.empty?(rpc_resources) do
      {:error, "No RPC resources found for #{otp_app}"}
    else
      # Get RPC configs for input/result type generation
      rpc_configs = get_rpc_configs(otp_app)

      # Generate comprehensive schema types
      {data_classes, embedded_classes, enum_classes, sealed_classes} =
        ResourceSchemas.generate_all_schemas(rpc_resources)

      # Generate action-specific input types
      input_types = InputTypes.generate_input_types(rpc_configs)

      # Generate action-specific result types
      action_result_types = ResultTypes.generate_result_types(rpc_configs)

      # Generate filter types if enabled
      filter_types =
        if Keyword.get(opts, :with_filters, AshKotlinMultiplatform.generate_filter_types?()) do
          FilterTypes.generate_all_filter_types(otp_app)
        else
          ""
        end

      # Generate typed queries if any exist
      typed_queries = TypedQueries.generate_from_config(otp_app)

      kotlin_code =
        [
          generate_header(package_name),
          generate_imports(opts),
          generate_type_aliases(),
          generate_error_types(),
          # Resource data classes
          non_empty_or_nil(data_classes, "// Resource Data Classes"),
          # Embedded resource classes
          non_empty_or_nil(embedded_classes, "// Embedded Resource Classes"),
          # Enum classes for atom types with :one_of
          non_empty_or_nil(enum_classes, "// Enum Classes"),
          # Sealed classes for union types
          non_empty_or_nil(sealed_classes, "// Union Sealed Classes"),
          # Generic result types
          generate_generic_result_types(),
          # Action-specific result types
          non_empty_or_nil(action_result_types, "// Action Result Types"),
          # Input types for actions
          non_empty_or_nil(input_types, "// Action Input Types"),
          # Filter types (if enabled)
          non_empty_or_nil(filter_types, "// Filter Types"),
          # Typed queries (if any)
          non_empty_or_nil(typed_queries, "// Typed Queries"),
          # Config types
          generate_config_types(otp_app),
          # RPC functions (functional style)
          generate_rpc_functions(otp_app),
          # Object wrappers (OO style)
          generate_object_wrappers(otp_app),
          # Phoenix Channel client (if enabled)
          maybe_generate_channel_client()
        ]
        |> Enum.reject(&is_nil/1)
        |> Enum.reject(&(&1 == ""))
        |> Enum.join("\n\n")

      {:ok, kotlin_code}
    end
  end

  defp get_rpc_configs(otp_app) do
    otp_app
    |> Ash.Info.domains()
    |> Enum.flat_map(&Info.kotlin_rpc/1)
  end

  defp non_empty_or_nil(content, _header) when content in [nil, ""], do: nil
  defp non_empty_or_nil(content, header), do: "#{header}\n#{content}"

  defp get_package_name(otp_app, opts) do
    case Keyword.get(opts, :package_name) || AshKotlinMultiplatform.default_package_name() do
      nil ->
        # Auto-generate from otp_app
        app_name =
          otp_app
          |> Atom.to_string()
          |> String.replace("_", "")

        "com.#{app_name}.ash"

      name ->
        name
    end
  end

  defp generate_header(package_name) do
    """
    // Generated by AshKotlinMultiplatform - Do not edit manually
    // https://github.com/ash-project/ash_interop

    package #{package_name}
    """
  end

  defp generate_imports(opts) do
    datetime_imports =
      case AshKotlinMultiplatform.datetime_library() do
        :kotlinx_datetime -> "import kotlinx.datetime.*"
        :java_time -> "import java.time.*"
      end

    websocket_imports =
      if AshKotlinMultiplatform.generate_phoenix_channel_client?() do
        """
        import io.ktor.client.plugins.websocket.*
        import io.ktor.websocket.*
        import kotlinx.coroutines.*
        """
      else
        ""
      end

    validation_imports =
      if Keyword.get(opts, :with_validation, false) do
        """
        import javax.validation.constraints.*
        """
      else
        ""
      end

    """
    import kotlinx.serialization.*
    import kotlinx.serialization.json.*
    #{datetime_imports}
    import io.ktor.client.*
    import io.ktor.client.call.*
    import io.ktor.client.request.*
    import io.ktor.http.*
    #{websocket_imports}#{validation_imports}
    """
  end

  defp generate_type_aliases do
    """
    // Type aliases for common types
    typealias UUID = String
    typealias Decimal = String
    """
  end

  defp generate_error_types do
    """
    // RPC Error types
    @Serializable
    data class AshRpcError(
        val type: String,
        val message: String,
        @SerialName("short_message")
        val shortMessage: String,
        val vars: Map<String, String> = emptyMap(),
        val fields: List<String> = emptyList(),
        val path: List<String> = emptyList(),
        val details: Map<String, @Contextual Any?>? = null
    )
    """
  end

  defp get_resource_type_name(resource) do
    # Try to get from DSL configuration first
    case AshKotlinMultiplatform.Resource.Info.kotlin_multiplatform_type_name(resource) do
      nil ->
        # Fall back to module name
        resource
        |> Module.split()
        |> List.last()

      name ->
        name
    end
  rescue
    # If the resource doesn't have the AshKotlinMultiplatform.Resource extension
    _ ->
      resource
      |> Module.split()
      |> List.last()
  end

  defp generate_generic_result_types do
    """
    // Generic result wrapper
    @Serializable
    sealed class RpcResult<T> {
        abstract val success: Boolean
    }

    @Serializable
    @SerialName("success")
    data class RpcSuccess<T>(
        override val success: Boolean = true,
        val data: T,
        val metadata: Map<String, @Contextual Any?>? = null
    ) : RpcResult<T>()

    @Serializable
    @SerialName("error")
    data class RpcError<T>(
        override val success: Boolean = false,
        val errors: List<AshRpcError>
    ) : RpcResult<T>()
    """
  end

  defp generate_config_types(otp_app) do
    otp_app
    |> Ash.Info.domains()
    |> Enum.flat_map(&Info.kotlin_rpc/1)
    |> Enum.flat_map(fn %{resource: resource, rpc_actions: actions} ->
      Enum.map(actions, fn action ->
        generate_config_type(resource, action)
      end)
    end)
    |> Enum.join("\n\n")
  end

  defp generate_config_type(_resource, %{name: name}) do
    config_name = "#{Helpers.snake_to_pascal_case(name)}Config"

    """
    data class #{config_name}(
        val input: Map<String, Any?> = emptyMap(),
        val fields: List<Any> = emptyList(),
        val tenant: String? = null,
        val headers: Map<String, String> = emptyMap()
    )
    """
  end

  defp generate_rpc_functions(otp_app) do
    otp_app
    |> Ash.Info.domains()
    |> Enum.flat_map(&Info.kotlin_rpc/1)
    |> Enum.flat_map(fn %{resource: resource, rpc_actions: actions} ->
      Enum.map(actions, fn action ->
        generate_rpc_function(resource, action)
      end)
    end)
    |> Enum.join("\n\n")
  end

  defp generate_rpc_function(_resource, %{name: name}) do
    function_name = Helpers.snake_to_camel_case(name)
    config_name = "#{Helpers.snake_to_pascal_case(name)}Config"
    endpoint = AshKotlinMultiplatform.run_endpoint()

    """
    suspend fun #{function_name}(
        client: HttpClient,
        config: #{config_name},
        endpoint: String = "#{endpoint}"
    ): RpcResult<Map<String, Any?>> {
        return client.post(endpoint) {
            contentType(ContentType.Application.Json)
            config.headers.forEach { (key, value) ->
                header(key, value)
            }
            setBody(buildJsonObject {
                put("action", "#{name}")
                put("input", Json.encodeToJsonElement(config.input))
                putJsonArray("fields") {
                    config.fields.forEach { field ->
                        when (field) {
                            is String -> add(field)
                            else -> add(Json.encodeToJsonElement(field))
                        }
                    }
                }
                config.tenant?.let { put("tenant", it) }
            })
        }.body()
    }
    """
  end

  defp generate_object_wrappers(otp_app) do
    otp_app
    |> Ash.Info.domains()
    |> Enum.flat_map(&Info.kotlin_rpc/1)
    |> Enum.group_by(fn %{resource: resource} -> resource end)
    |> Enum.map(fn {resource, configs} ->
      generate_object_wrapper(resource, List.first(configs))
    end)
    |> Enum.join("\n\n")
  end

  defp generate_object_wrapper(resource, %{rpc_actions: actions}) do
    type_name = get_resource_type_name(resource)
    object_name = "#{type_name}Rpc"

    functions =
      actions
      |> Enum.map(fn %{name: name} ->
        function_name = Helpers.snake_to_camel_case(name)
        config_name = "#{Helpers.snake_to_pascal_case(name)}Config"

        # Determine method name for OO API
        method_name = determine_method_name(name)

        "    suspend fun #{method_name}(client: HttpClient, config: #{config_name}) = #{function_name}(client, config)"
      end)
      |> Enum.join("\n")

    """
    object #{object_name} {
    #{functions}
    }
    """
  end

  defp determine_method_name(action_name) do
    name_str = Atom.to_string(action_name)

    cond do
      String.starts_with?(name_str, "list_") -> "list"
      String.starts_with?(name_str, "get_") -> "get"
      String.starts_with?(name_str, "create_") -> "create"
      String.starts_with?(name_str, "update_") -> "update"
      String.starts_with?(name_str, "delete_") -> "delete"
      String.starts_with?(name_str, "destroy_") -> "destroy"
      true -> Helpers.snake_to_camel_case(action_name)
    end
  end

  defp maybe_generate_channel_client do
    if AshKotlinMultiplatform.generate_phoenix_channel_client?() do
      "// Phoenix Channel Client\n// Note: Requires Ktor WebSocket client dependency\n\n" <>
        PhoenixChannel.generate()
    else
      nil
    end
  end
end
