# SPDX-FileCopyrightText: 2025 ash_kotlin_multiplatform contributors
#
# SPDX-License-Identifier: MIT

defmodule AshKotlinMultiplatform.Swift.Codegen do
  @moduledoc """
  Generates Swift code from Ash resources.

  This module generates:
  - Swift structs for Ash resources (with Codable conformance)
  - Enum types for Ash.Type.Atom with :one_of constraints
  - Service classes for RPC endpoints
  - Error types and result wrappers
  """

  alias AshKotlinMultiplatform.Swift.TypeMapper
  alias AshKotlinMultiplatform.Rpc.Codegen.RpcConfigCollector
  alias AshIntrospection.Helpers

  @doc """
  Generates Swift code for the given OTP application.

  ## Parameters
  - `otp_app` - The OTP application name
  - `opts` - Generation options

  ## Returns
  `{:ok, swift_code}` or `{:error, reason}`
  """
  def generate_swift_code(otp_app, opts \\ []) do
    rpc_resources = RpcConfigCollector.get_rpc_resources(otp_app)

    if Enum.empty?(rpc_resources) do
      {:error, "No RPC resources found for #{otp_app}"}
    else
      domains = Ash.Info.domains(otp_app)

      case AshKotlinMultiplatform.VerifierChecker.check_all_verifiers(rpc_resources ++ domains) do
        :ok ->
          generate_full_swift_code(otp_app, rpc_resources, opts)

        {:error, error_message} ->
          {:error, error_message}
      end
    end
  end

  defp generate_full_swift_code(otp_app, rpc_resources, opts) do
    rpc_configs = RpcConfigCollector.get_rpc_configs(otp_app)
    base_url = Keyword.get(opts, :base_url, "http://localhost:4000")

    # Generate all components
    {data_structs, enums} = generate_all_schemas(rpc_resources)
    input_types = generate_input_types(rpc_configs)
    rpc_functions = generate_rpc_service(rpc_configs, base_url)

    swift_code =
      [
        generate_header(),
        generate_imports(),
        "// MARK: - Error Types",
        generate_error_types(),
        "// MARK: - Result Types",
        generate_result_types(),
        "// MARK: - Data Models",
        data_structs,
        "// MARK: - Enums",
        enums,
        "// MARK: - Input Types",
        input_types,
        "// MARK: - RPC Service",
        rpc_functions
      ]
      |> Enum.reject(&(&1 == "" or is_nil(&1)))
      |> Enum.join("\n\n")

    {:ok, swift_code}
  end

  defp generate_header do
    """
    // Generated by AshKotlinMultiplatform - Do not edit manually
    // https://github.com/ash-project/ash_interop
    """
  end

  defp generate_imports do
    """
    import Foundation
    """
  end

  defp generate_error_types do
    """
    struct AshRpcError: Codable, Error {
        let type: String
        let message: String
        let shortMessage: String
        let field: String?

        enum CodingKeys: String, CodingKey {
            case type
            case message
            case shortMessage
            case field
        }
    }
    """
  end

  defp generate_result_types do
    """
    struct EmptyInput: Codable {}

    struct RpcResult<T: Codable>: Codable {
        let success: Bool
        let data: T?
        let errors: [AshRpcError]?
        let metadata: [String: AnyCodable]?

        enum CodingKeys: String, CodingKey {
            case success
            case data
            case errors
            case metadata
        }
    }

    struct RpcListResult<T: Codable>: Codable {
        let success: Bool
        let data: [T]?
        let errors: [AshRpcError]?

        enum CodingKeys: String, CodingKey {
            case success
            case data
            case errors
        }
    }

    struct EmptyResult: Codable {
        let success: Bool
        let errors: [AshRpcError]?
    }

    // Type-erased Codable for dynamic JSON values
    struct AnyCodable: Codable {
        let value: Any

        init(_ value: Any) {
            self.value = value
        }

        init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()

            if container.decodeNil() {
                self.value = NSNull()
            } else if let bool = try? container.decode(Bool.self) {
                self.value = bool
            } else if let int = try? container.decode(Int.self) {
                self.value = int
            } else if let double = try? container.decode(Double.self) {
                self.value = double
            } else if let string = try? container.decode(String.self) {
                self.value = string
            } else if let array = try? container.decode([AnyCodable].self) {
                self.value = array.map { $0.value }
            } else if let dict = try? container.decode([String: AnyCodable].self) {
                self.value = dict.mapValues { $0.value }
            } else {
                throw DecodingError.dataCorruptedError(in: container, debugDescription: "Unsupported type")
            }
        }

        func encode(to encoder: Encoder) throws {
            var container = encoder.singleValueContainer()

            switch value {
            case is NSNull:
                try container.encodeNil()
            case let bool as Bool:
                try container.encode(bool)
            case let int as Int:
                try container.encode(int)
            case let double as Double:
                try container.encode(double)
            case let string as String:
                try container.encode(string)
            case let array as [Any]:
                try container.encode(array.map { AnyCodable($0) })
            case let dict as [String: Any]:
                try container.encode(dict.mapValues { AnyCodable($0) })
            default:
                throw EncodingError.invalidValue(value, EncodingError.Context(codingPath: encoder.codingPath, debugDescription: "Unsupported type"))
            }
        }
    }
    """
  end

  # ---------------------------------------------------------------------------
  # Schema Generation
  # ---------------------------------------------------------------------------

  defp generate_all_schemas(resources) do
    {enums, embedded} = collect_types(resources)

    data_structs =
      (resources ++ embedded)
      |> Enum.uniq()
      |> Enum.map(&generate_struct/1)
      |> Enum.join("\n\n")

    enum_code =
      enums
      |> Enum.uniq_by(fn {name, _} -> name end)
      |> Enum.map(&generate_enum/1)
      |> Enum.join("\n\n")

    {data_structs, enum_code}
  end

  defp collect_types(resources) do
    resources
    |> Enum.reduce({[], []}, fn resource, {enums, embedded} ->
      attributes = Ash.Resource.Info.public_attributes(resource)

      Enum.reduce(attributes, {enums, embedded}, fn attr, {e, emb} ->
        collect_types_from_attribute(attr, e, emb)
      end)
    end)
  end

  defp collect_types_from_attribute(attr, enums, embedded) do
    type = attr.type
    constraints = attr.constraints || []

    case type do
      Ash.Type.Atom ->
        case Keyword.get(constraints, :one_of) do
          nil -> {enums, embedded}
          values ->
            enum_name = generate_enum_name(attr.name)
            {[{enum_name, values} | enums], embedded}
        end

      {:array, inner_type} ->
        if AshIntrospection.TypeSystem.Introspection.is_embedded_resource?(inner_type) do
          {enums, [inner_type | embedded]}
        else
          {enums, embedded}
        end

      _ ->
        if AshIntrospection.TypeSystem.Introspection.is_embedded_resource?(type) do
          {enums, [type | embedded]}
        else
          {enums, embedded}
        end
    end
  end

  defp generate_struct(resource) do
    type_name = get_swift_type_name(resource)
    attributes = Ash.Resource.Info.public_attributes(resource)
    relationships = get_public_relationships(resource)

    attribute_fields =
      attributes
      |> Enum.map(&generate_field/1)

    relationship_fields =
      relationships
      |> Enum.map(&generate_relationship_field/1)

    all_fields = attribute_fields ++ relationship_fields
    fields_str = all_fields |> Enum.join("\n    ")

    coding_keys = generate_coding_keys(attributes, relationships)

    """
    struct #{type_name}: Codable, Identifiable {
        #{fields_str}
        #{coding_keys}
    }
    """
  end

  defp get_public_relationships(resource) do
    try do
      Ash.Resource.Info.public_relationships(resource)
    rescue
      _ -> []
    end
  end

  defp generate_field(attribute) do
    swift_type = TypeMapper.get_swift_type(attribute)
    field_name = format_field_name(attribute.name)

    # All fields except `id` are optional for sparse fieldsets
    {swift_type, default} =
      cond do
        attribute.name == :id ->
          {swift_type, ""}

        attribute.allow_nil? ->
          {swift_type, " = nil"}

        true ->
          nullable_type = make_nullable(swift_type)
          {nullable_type, " = nil"}
      end

    "let #{field_name}: #{swift_type}#{default}"
  end

  defp generate_relationship_field(rel) do
    field_name = format_field_name(rel.name)
    related_type_name = get_swift_type_name(rel.destination)

    swift_type =
      case rel.type do
        :has_many -> "[#{related_type_name}]?"
        :many_to_many -> "[#{related_type_name}]?"
        :belongs_to -> "#{related_type_name}?"
        :has_one -> "#{related_type_name}?"
        _ -> "#{related_type_name}?"
      end

    "let #{field_name}: #{swift_type} = nil"
  end

  defp generate_coding_keys(_attributes, _relationships) do
    # Swift's Codable uses camelCase by default, which matches our server output
    # CodingKeys are only needed if we have snake_case keys from server
    # Since output_field_formatter defaults to :camel_case, we don't need CodingKeys
    ""
  end

  defp generate_enum({enum_name, values}) do
    cases =
      values
      |> Enum.map(fn value ->
        case_name = value |> Atom.to_string() |> format_enum_case()
        raw_value = Atom.to_string(value)
        "    case #{case_name} = \"#{raw_value}\""
      end)
      |> Enum.join("\n")

    """
    enum #{enum_name}: String, Codable {
    #{cases}
    }
    """
  end

  defp format_enum_case(string) do
    string
    |> String.replace("-", "_")
    |> Helpers.snake_to_camel_case()
  end

  defp make_nullable(swift_type) do
    if String.ends_with?(swift_type, "?") do
      swift_type
    else
      "#{swift_type}?"
    end
  end

  # ---------------------------------------------------------------------------
  # Input Types
  # ---------------------------------------------------------------------------

  defp generate_input_types(rpc_configs) do
    rpc_configs
    |> Enum.map(&generate_input_type/1)
    |> Enum.reject(&is_nil/1)
    |> Enum.join("\n\n")
  end

  defp generate_input_type(%{resource: resource, rpc_actions: rpc_actions}) do
    rpc_actions
    |> Enum.filter(fn action ->
      action_info = Ash.Resource.Info.action(resource, action.action)
      action_info && action_info.type in [:create, :update]
    end)
    |> Enum.map(fn rpc_action ->
      action_info = Ash.Resource.Info.action(resource, rpc_action.action)
      generate_action_input_type(rpc_action.name, action_info)
    end)
    |> Enum.reject(&is_nil/1)
    |> Enum.join("\n\n")
  end

  defp generate_action_input_type(action_name, action_info) do
    arguments = action_info.arguments || []

    if Enum.empty?(arguments) do
      nil
    else
      type_name = "#{Helpers.snake_to_pascal_case(action_name)}Input"

      fields =
        arguments
        |> Enum.map(fn arg ->
          swift_type = TypeMapper.get_swift_type_for_type(arg.type, arg.constraints || [])
          field_name = format_field_name(arg.name)

          if arg.allow_nil? do
            "    let #{field_name}: #{swift_type}?"
          else
            "    let #{field_name}: #{swift_type}"
          end
        end)
        |> Enum.join("\n")

      """
      struct #{type_name}: Codable {
      #{fields}
      }
      """
    end
  end

  # ---------------------------------------------------------------------------
  # RPC Service
  # ---------------------------------------------------------------------------

  defp generate_rpc_service(rpc_configs, base_url) do
    functions =
      rpc_configs
      |> Enum.flat_map(fn %{resource: resource, rpc_actions: rpc_actions} ->
        Enum.map(rpc_actions, fn rpc_action ->
          action_info = Ash.Resource.Info.action(resource, rpc_action.action)
          generate_rpc_function(resource, rpc_action, action_info)
        end)
      end)
      |> Enum.join("\n\n")

    """
    actor AshRpcService {
        private let baseURL: String
        private let session: URLSession
        private var authToken: String?

        init(baseURL: String = "#{base_url}", session: URLSession = .shared) {
            self.baseURL = baseURL
            self.session = session
        }

        func setAuthToken(_ token: String?) {
            self.authToken = token
        }

        private func makeRequest<T: Codable, R: Codable>(
            action: String,
            input: T?,
            identity: String? = nil,
            fields: [String]? = nil
        ) async throws -> RpcResult<R> {
            guard let url = URL(string: "\\(baseURL)/api/rpc/run") else {
                throw URLError(.badURL)
            }

            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")

            if let token = authToken {
                request.setValue("Bearer \\(token)", forHTTPHeaderField: "Authorization")
            }

            var body: [String: Any] = ["action": action]

            if let input = input {
                let inputData = try JSONEncoder().encode(input)
                if let inputDict = try JSONSerialization.jsonObject(with: inputData) as? [String: Any] {
                    body["input"] = inputDict
                }
            }

            if let identity = identity {
                body["identity"] = identity
            }

            if let fields = fields {
                body["fields"] = fields
            }

            request.httpBody = try JSONSerialization.data(withJSONObject: body)

            let (data, _) = try await session.data(for: request)
            return try JSONDecoder().decode(RpcResult<R>.self, from: data)
        }

        private func makeListRequest<T: Codable, R: Codable>(
            action: String,
            input: T?,
            fields: [String]? = nil
        ) async throws -> RpcListResult<R> {
            guard let url = URL(string: "\\(baseURL)/api/rpc/run") else {
                throw URLError(.badURL)
            }

            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")

            if let token = authToken {
                request.setValue("Bearer \\(token)", forHTTPHeaderField: "Authorization")
            }

            var body: [String: Any] = ["action": action]

            if let input = input {
                let inputData = try JSONEncoder().encode(input)
                if let inputDict = try JSONSerialization.jsonObject(with: inputData) as? [String: Any] {
                    body["input"] = inputDict
                }
            }

            if let fields = fields {
                body["fields"] = fields
            }

            request.httpBody = try JSONSerialization.data(withJSONObject: body)

            let (data, _) = try await session.data(for: request)
            return try JSONDecoder().decode(RpcListResult<R>.self, from: data)
        }

    #{functions}
    }
    """
  end

  defp generate_rpc_function(resource, rpc_action, action_info) do
    function_name = Helpers.snake_to_camel_case(rpc_action.name)
    resource_type = get_swift_type_name(resource)
    action_type = action_info.type

    case action_type do
      :read ->
        if Map.get(action_info, :get?, false) do
          generate_get_function(function_name, resource_type, rpc_action)
        else
          generate_list_function(function_name, resource_type, rpc_action)
        end

      :create ->
        generate_create_function(function_name, resource_type, rpc_action, action_info)

      :update ->
        generate_update_function(function_name, resource_type, rpc_action, action_info)

      :destroy ->
        generate_destroy_function(function_name, rpc_action)

      :action ->
        generate_generic_action_function(function_name, resource_type, rpc_action, action_info)
    end
  end

  defp generate_list_function(function_name, resource_type, rpc_action) do
    action_name = Atom.to_string(rpc_action.name)

    """
        func #{function_name}(fields: [String]? = nil) async throws -> RpcListResult<#{resource_type}> {
            try await makeListRequest(
                action: "#{action_name}",
                input: nil as EmptyInput?,
                fields: fields
            )
        }
    """
  end

  defp generate_get_function(function_name, resource_type, rpc_action) do
    action_name = Atom.to_string(rpc_action.name)

    """
        func #{function_name}(id: String, fields: [String]? = nil) async throws -> RpcResult<#{resource_type}> {
            try await makeRequest(
                action: "#{action_name}",
                input: nil as EmptyInput?,
                identity: id,
                fields: fields
            )
        }
    """
  end

  defp generate_create_function(function_name, resource_type, rpc_action, action_info) do
    action_name = Atom.to_string(rpc_action.name)
    input_type_name = "#{Helpers.snake_to_pascal_case(rpc_action.name)}Input"

    has_args = action_info.arguments && length(action_info.arguments) > 0

    if has_args do
      """
          func #{function_name}(input: #{input_type_name}, fields: [String]? = nil) async throws -> RpcResult<#{resource_type}> {
              try await makeRequest(
                  action: "#{action_name}",
                  input: input,
                  fields: fields
              )
          }
      """
    else
      """
          func #{function_name}(fields: [String]? = nil) async throws -> RpcResult<#{resource_type}> {
              try await makeRequest(
                  action: "#{action_name}",
                  input: nil as EmptyInput?,
                  fields: fields
              )
          }
      """
    end
  end

  defp generate_update_function(function_name, resource_type, rpc_action, action_info) do
    action_name = Atom.to_string(rpc_action.name)
    input_type_name = "#{Helpers.snake_to_pascal_case(rpc_action.name)}Input"

    has_args = action_info.arguments && length(action_info.arguments) > 0

    if has_args do
      """
          func #{function_name}(id: String, input: #{input_type_name}, fields: [String]? = nil) async throws -> RpcResult<#{resource_type}> {
              try await makeRequest(
                  action: "#{action_name}",
                  input: input,
                  identity: id,
                  fields: fields
              )
          }
      """
    else
      """
          func #{function_name}(id: String, fields: [String]? = nil) async throws -> RpcResult<#{resource_type}> {
              try await makeRequest(
                  action: "#{action_name}",
                  input: nil as EmptyInput?,
                  identity: id,
                  fields: fields
              )
          }
      """
    end
  end

  defp generate_destroy_function(function_name, rpc_action) do
    action_name = Atom.to_string(rpc_action.name)

    """
        func #{function_name}(id: String) async throws -> EmptyResult {
            guard let url = URL(string: "\\(baseURL)/api/rpc/run") else {
                throw URLError(.badURL)
            }

            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")

            if let token = authToken {
                request.setValue("Bearer \\(token)", forHTTPHeaderField: "Authorization")
            }

            let body: [String: Any] = ["action": "#{action_name}", "identity": id]
            request.httpBody = try JSONSerialization.data(withJSONObject: body)

            let (data, _) = try await session.data(for: request)
            return try JSONDecoder().decode(EmptyResult.self, from: data)
        }
    """
  end

  defp generate_generic_action_function(function_name, resource_type, rpc_action, action_info) do
    action_name = Atom.to_string(rpc_action.name)
    has_args = action_info.arguments && length(action_info.arguments) > 0
    input_type_name = "#{Helpers.snake_to_pascal_case(rpc_action.name)}Input"

    if has_args do
      """
          func #{function_name}(input: #{input_type_name}, fields: [String]? = nil) async throws -> RpcResult<#{resource_type}> {
              try await makeRequest(
                  action: "#{action_name}",
                  input: input,
                  fields: fields
              )
          }
      """
    else
      """
          func #{function_name}(fields: [String]? = nil) async throws -> RpcResult<#{resource_type}> {
              try await makeRequest(
                  action: "#{action_name}",
                  input: nil as EmptyInput?,
                  fields: fields
              )
          }
      """
    end
  end

  # ---------------------------------------------------------------------------
  # Helpers
  # ---------------------------------------------------------------------------

  defp get_swift_type_name(resource) do
    case AshKotlinMultiplatform.Resource.Info.kotlin_multiplatform_type_name(resource) do
      nil ->
        resource
        |> Module.split()
        |> List.last()

      name ->
        name
    end
  rescue
    _ ->
      resource
      |> Module.split()
      |> List.last()
  end

  defp format_field_name(name) do
    name
    |> Atom.to_string()
    |> Helpers.snake_to_camel_case()
  end

  defp generate_enum_name(attr_name) do
    attr_name
    |> Atom.to_string()
    |> Helpers.snake_to_pascal_case()
  end
end
